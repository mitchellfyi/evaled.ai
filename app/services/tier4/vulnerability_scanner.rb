# frozen_string_literal: true

module Tier4
  class VulnerabilityScanner
    SECRET_PATTERNS = {
      aws_key: /AKIA[0-9A-Z]{16}/i,
      github_token: /gh[ps]_[A-Za-z0-9]{36,}/,
      openai_key: /sk-[A-Za-z0-9]{48}/,
      generic_api_key: /api[_-]?key['":\s]*[=:]\s*['"]?[A-Za-z0-9]{20,}/i,
      private_key: /-----BEGIN (RSA |EC |DSA )?PRIVATE KEY-----/,
      jwt_token: /eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/
    }.freeze

    CODE_PATTERNS = {
      sql_injection: /execute\s*\(.*\#\{/i,
      command_injection: /`.*\#\{|system\s*\(.*\#\{|exec\s*\(.*\#\{/i,
      eval_usage: /\beval\s*\(/,
      unsafe_yaml: /YAML\.load[^_]/,
      mass_assignment: /params\.permit!/
    }.freeze

    def initialize(github_client: GithubClient.new)
      @github_client = github_client
    end

    def scan(agent)
      findings = []
      findings.concat(scan_dependencies(agent))
      findings.concat(scan_code(agent))
      findings.concat(scan_secrets(agent))
      findings.concat(scan_container(agent))

      severity_counts = count_severities(findings)
      passed = severity_counts[:critical].zero? && severity_counts[:high].zero?

      SecurityScan.create!(
        agent: agent,
        scan_type: "full",
        findings: findings,
        severity_counts: severity_counts,
        passed: passed,
        scanned_at: Time.current
      )
    end

    def scan_dependencies(agent)
      return [] unless agent.repo_url.present?

      owner, name = parse_repo(agent.repo_url)
      return [] unless owner && name

      alerts = @github_client.dependabot_alerts(owner, name)
      return [] unless alerts.is_a?(Array)

      alerts.map do |alert|
        {
          type: "dependency",
          package: alert.dig("security_vulnerability", "package", "name"),
          severity: alert.dig("security_vulnerability", "severity") || "unknown",
          summary: alert.dig("security_advisory", "summary"),
          cve: alert.dig("security_advisory", "cve_id"),
          url: alert.dig("html_url")
        }
      end
    end

    def scan_code(agent)
      return [] unless agent.repo_url.present?

      owner, name = parse_repo(agent.repo_url)
      return [] unless owner && name

      findings = []

      # Fetch common code files for static analysis
      code_paths = [
        "app/controllers/application_controller.rb",
        "app/models/user.rb",
        "config/routes.rb",
        "lib/tasks"
      ]

      code_paths.each do |path|
        content = @github_client.contents(owner, name, path)
        next unless content.is_a?(Hash) && content["content"]

        decoded = Base64.decode64(content["content"]) rescue next

        CODE_PATTERNS.each do |vuln_type, pattern|
          if decoded.match?(pattern)
            findings << {
              type: "code",
              vulnerability: vuln_type.to_s.humanize,
              severity: code_severity(vuln_type),
              file: path,
              summary: "Potential #{vuln_type.to_s.humanize} vulnerability detected"
            }
          end
        end
      end

      findings
    end

    def scan_secrets(agent)
      return [] unless agent.repo_url.present?

      owner, name = parse_repo(agent.repo_url)
      return [] unless owner && name

      findings = []

      # Check common files where secrets might leak
      secret_paths = [
        ".env.example",
        "config/secrets.yml",
        "config/credentials.yml.enc",
        "docker-compose.yml",
        "README.md"
      ]

      secret_paths.each do |path|
        content = @github_client.contents(owner, name, path)
        next unless content.is_a?(Hash) && content["content"]

        decoded = Base64.decode64(content["content"]) rescue next

        SECRET_PATTERNS.each do |secret_type, pattern|
          if decoded.match?(pattern)
            findings << {
              type: "secret",
              secret_type: secret_type.to_s.humanize,
              severity: "critical",
              file: path,
              summary: "Potential #{secret_type.to_s.humanize} exposure detected"
            }
          end
        end
      end

      findings
    end

    def scan_container(agent)
      return [] unless agent.repo_url.present?

      owner, name = parse_repo(agent.repo_url)
      return [] unless owner && name

      findings = []

      dockerfile = @github_client.contents(owner, name, "Dockerfile")
      return findings unless dockerfile.is_a?(Hash) && dockerfile["content"]

      begin
        content = Base64.decode64(dockerfile["content"])
      rescue StandardError
        return findings
      end

      # Check for common Dockerfile security issues
      if content.match?(/FROM\s+\S+:latest/i)
        findings << {
          type: "container",
          vulnerability: "Unpinned base image",
          severity: "medium",
          file: "Dockerfile",
          summary: "Using :latest tag makes builds non-reproducible and may introduce vulnerabilities"
        }
      end

      if content.match?(/USER\s+root/i) || !content.match?(/USER\s+\w+/i)
        findings << {
          type: "container",
          vulnerability: "Running as root",
          severity: "high",
          file: "Dockerfile",
          summary: "Container runs as root user, increasing attack surface"
        }
      end

      if content.match?(/curl.*\|\s*sh/i) || content.match?(/wget.*\|\s*sh/i)
        findings << {
          type: "container",
          vulnerability: "Unsafe script execution",
          severity: "high",
          file: "Dockerfile",
          summary: "Piping remote scripts directly to shell is dangerous"
        }
      end

      findings
    end

    def count_severities(findings)
      counts = { critical: 0, high: 0, medium: 0, low: 0, unknown: 0 }

      findings.each do |finding|
        severity = finding[:severity]&.to_s&.downcase&.to_sym || :unknown
        severity = :unknown unless counts.key?(severity)
        counts[severity] += 1
      end

      counts
    end

    private

    def parse_repo(repo_url)
      return nil unless repo_url

      match = repo_url.match(%r{github\.com[:/]([^/]+)/([^/.]+)})
      return nil unless match

      [ match[1], match[2] ]
    end

    def code_severity(vuln_type)
      case vuln_type
      when :sql_injection, :command_injection
        "critical"
      when :eval_usage, :unsafe_yaml
        "high"
      when :mass_assignment
        "medium"
      else
        "low"
      end
    end
  end
end
